// This code contains NVIDIA Confidential Information and is disclosed to you 
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and 
// any modifications thereto. Any use, reproduction, disclosure, or 
// distribution of this software and related documentation without an express 
// license agreement from NVIDIA Corporation is strictly prohibited.
// 
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2012 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

// This code is auto-generated by the PhysX Clang metadata generator.  Do not edit or be
// prepared for your edits to be quietly ignored next time the clang metadata generator is
// run.  You can find the most recent version of clang metadata generator by contacting
// Chris Nuernberger <chrisn@nvidia.com> or Dilip or Adam.
// The source code for the generate was at one time checked into:
// physx/PhysXMetaDataGenerator/llvm/tools/clang/lib/Frontend/PhysXMetaDataAction.cpp
#define THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON

#define PX_PROPERTY_INFO_NAME PxPropertyInfoName
	static PxU32ToName g_physx__PxMaterialFlag__EnumConversion[] = {
		{ "eDISABLE_FRICTION", static_cast<PxU32>( physx::PxMaterialFlag::eDISABLE_FRICTION ) },
		{ "eDISABLE_STRONG_FRICTION", static_cast<PxU32>( physx::PxMaterialFlag::eDISABLE_STRONG_FRICTION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxMaterialFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxMaterialFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxCombineMode__EnumConversion[] = {
		{ "eAVERAGE", static_cast<PxU32>( physx::PxCombineMode::eAVERAGE ) },
		{ "eMIN", static_cast<PxU32>( physx::PxCombineMode::eMIN ) },
		{ "eMULTIPLY", static_cast<PxU32>( physx::PxCombineMode::eMULTIPLY ) },
		{ "eMAX", static_cast<PxU32>( physx::PxCombineMode::eMAX ) },
		{ "eN_VALUES", static_cast<PxU32>( physx::PxCombineMode::eN_VALUES ) },
		{ "ePAD_32", static_cast<PxU32>( physx::PxCombineMode::ePAD_32 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxCombineMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxCombineMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxMaterial;
	struct PxMaterialGeneratedValues
	{
		PxU32 ReferenceCount;
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxReal Restitution;
		PxMaterialFlags Flags;
		PxCombineMode::Enum FrictionCombineMode;
		PxCombineMode::Enum RestitutionCombineMode;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxMaterialGeneratedValues( const PxMaterial* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, ReferenceCount, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, DynamicFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, StaticFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Restitution, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Flags, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, FrictionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, RestitutionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, ConcreteTypeName, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, UserData, PxMaterialGeneratedValues)
	struct PxMaterialGeneratedInfo

	{
		static const char* getClassName() { return "PxMaterial"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_ReferenceCount, PxMaterial, PxU32 > ReferenceCount;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_DynamicFriction, PxMaterial, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_StaticFriction, PxMaterial, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Restitution, PxMaterial, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Flags, PxMaterial, PxMaterialFlags, PxMaterialFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_FrictionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > FrictionCombineMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_RestitutionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > RestitutionCombineMode;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_ConcreteTypeName, PxMaterial, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_UserData, PxMaterial, void *, void * > UserData;

		PX_PHYSX_CORE_API PxMaterialGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxMaterial*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ReferenceCount, inStartIndex + 0 );; 
			inOperator( DynamicFriction, inStartIndex + 1 );; 
			inOperator( StaticFriction, inStartIndex + 2 );; 
			inOperator( Restitution, inStartIndex + 3 );; 
			inOperator( Flags, inStartIndex + 4 );; 
			inOperator( FrictionCombineMode, inStartIndex + 5 );; 
			inOperator( RestitutionCombineMode, inStartIndex + 6 );; 
			inOperator( ConcreteTypeName, inStartIndex + 7 );; 
			inOperator( UserData, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMaterial> { PxMaterialGeneratedInfo Info; };

	static PxU32ToName g_physx__PxActorType__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( physx::PxActorType::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( physx::PxActorType::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxActorType::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( physx::PxActorType::ePARTICLE_FLUID ) },
		{ "eARTICULATION_LINK", static_cast<PxU32>( physx::PxActorType::eARTICULATION_LINK ) },
		{ "eCLOTH", static_cast<PxU32>( physx::PxActorType::eCLOTH ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxActorFlag__EnumConversion[] = {
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxActorFlag::eVISUALIZATION ) },
		{ "eDISABLE_GRAVITY", static_cast<PxU32>( physx::PxActorFlag::eDISABLE_GRAVITY ) },
		{ "eSEND_SLEEP_NOTIFIES", static_cast<PxU32>( physx::PxActorFlag::eSEND_SLEEP_NOTIFIES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxActor;
	struct PxActorGeneratedValues
	{
		PxScene * Scene;
		const char * Name;
		PxBounds3 WorldBounds;
		PxActorFlags ActorFlags;
		PxDominanceGroup DominanceGroup;
		PxClientID OwnerClient;
		PxU32 ClientBehaviorBits;
		PxAggregate * Aggregate;
		void * UserData;
		 PX_PHYSX_CORE_API PxActorGeneratedValues( const PxActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Scene, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Name, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, WorldBounds, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ActorFlags, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, DominanceGroup, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, OwnerClient, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ClientBehaviorBits, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Aggregate, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, UserData, PxActorGeneratedValues)
	struct PxActorGeneratedInfo

	{
		static const char* getClassName() { return "PxActor"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Scene, PxActor, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Name, PxActor, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_WorldBounds, PxActor, PxBounds3 > WorldBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ActorFlags, PxActor, PxActorFlags, PxActorFlags > ActorFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_DominanceGroup, PxActor, PxDominanceGroup, PxDominanceGroup > DominanceGroup;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_OwnerClient, PxActor, PxClientID, PxClientID > OwnerClient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ClientBehaviorBits, PxActor, PxU32, PxU32 > ClientBehaviorBits;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Aggregate, PxActor, PxAggregate * > Aggregate;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_UserData, PxActor, void *, void * > UserData;

		PX_PHYSX_CORE_API PxActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( Name, inStartIndex + 1 );; 
			inOperator( WorldBounds, inStartIndex + 2 );; 
			inOperator( ActorFlags, inStartIndex + 3 );; 
			inOperator( DominanceGroup, inStartIndex + 4 );; 
			inOperator( OwnerClient, inStartIndex + 5 );; 
			inOperator( ClientBehaviorBits, inStartIndex + 6 );; 
			inOperator( Aggregate, inStartIndex + 7 );; 
			inOperator( UserData, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxActor> { PxActorGeneratedInfo Info; };

	class PxRigidActor;
	struct PxRigidActorGeneratedValues
		: PxActorGeneratedValues	{
		PxTransform GlobalPose;
		 PX_PHYSX_CORE_API PxRigidActorGeneratedValues( const PxRigidActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidActor, GlobalPose, PxRigidActorGeneratedValues)
	struct PxRigidActorGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidActor"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_GlobalPose, PxRigidActor, const PxTransform &, PxTransform > GlobalPose;
		PxRigidActorShapeCollection Shapes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_Constraints, PxRigidActor, PxConstraint * > Constraints;

		PX_PHYSX_CORE_API PxRigidActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( GlobalPose, inStartIndex + 0 );; 
			inOperator( Shapes, inStartIndex + 1 );; 
			inOperator( Constraints, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidActor> { PxRigidActorGeneratedInfo Info; };

	static PxU32ToName g_physx__PxForceMode__EnumConversion[] = {
		{ "eFORCE", static_cast<PxU32>( physx::PxForceMode::eFORCE ) },
		{ "eIMPULSE", static_cast<PxU32>( physx::PxForceMode::eIMPULSE ) },
		{ "eVELOCITY_CHANGE", static_cast<PxU32>( physx::PxForceMode::eVELOCITY_CHANGE ) },
		{ "eACCELERATION", static_cast<PxU32>( physx::PxForceMode::eACCELERATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxForceMode::Enum > { PxEnumTraits() : NameConversion( g_physx__PxForceMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidBody;
	struct PxRigidBodyGeneratedValues
		: PxRigidActorGeneratedValues	{
		PxTransform CMassLocalPose;
		PxReal Mass;
		PxVec3 MassSpaceInertiaTensor;
		PxVec3 LinearVelocity;
		PxVec3 AngularVelocity;
		 PX_PHYSX_CORE_API PxRigidBodyGeneratedValues( const PxRigidBody* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, CMassLocalPose, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, Mass, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MassSpaceInertiaTensor, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, LinearVelocity, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, AngularVelocity, PxRigidBodyGeneratedValues)
	struct PxRigidBodyGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidBody"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_CMassLocalPose, PxRigidBody, const PxTransform &, PxTransform > CMassLocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_Mass, PxRigidBody, PxReal, PxReal > Mass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MassSpaceInertiaTensor, PxRigidBody, const PxVec3 &, PxVec3 > MassSpaceInertiaTensor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_LinearVelocity, PxRigidBody, const PxVec3 &, PxVec3 > LinearVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_AngularVelocity, PxRigidBody, const PxVec3 &, PxVec3 > AngularVelocity;

		PX_PHYSX_CORE_API PxRigidBodyGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidBody*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( CMassLocalPose, inStartIndex + 0 );; 
			inOperator( Mass, inStartIndex + 1 );; 
			inOperator( MassSpaceInertiaTensor, inStartIndex + 2 );; 
			inOperator( LinearVelocity, inStartIndex + 3 );; 
			inOperator( AngularVelocity, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidBody> { PxRigidBodyGeneratedInfo Info; };

	static PxU32ToName g_physx__PxRigidDynamicFlag__EnumConversion[] = {
		{ "eKINEMATIC", static_cast<PxU32>( physx::PxRigidDynamicFlag::eKINEMATIC ) },
		{ "eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES", static_cast<PxU32>( physx::PxRigidDynamicFlag::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxRigidDynamicFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxRigidDynamicFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidDynamic;
	struct PxRigidDynamicGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxReal LinearDamping;
		PxReal AngularDamping;
		PxReal MaxAngularVelocity;
		_Bool IsSleeping;
		PxReal SleepThreshold;
		PxU32 SolverIterationCounts[2];
		PxReal ContactReportThreshold;
		PxRigidDynamicFlags RigidDynamicFlags;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxRigidDynamicGeneratedValues( const PxRigidDynamic* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, LinearDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, AngularDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, MaxAngularVelocity, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, IsSleeping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SleepThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SolverIterationCounts, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, ContactReportThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, RigidDynamicFlags, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, ConcreteTypeName, PxRigidDynamicGeneratedValues)
	struct PxRigidDynamicGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidDynamic"; }
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_KinematicTarget, PxRigidDynamic, const PxTransform & > KinematicTarget;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_LinearDamping, PxRigidDynamic, PxReal, PxReal > LinearDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_AngularDamping, PxRigidDynamic, PxReal, PxReal > AngularDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_MaxAngularVelocity, PxRigidDynamic, PxReal, PxReal > MaxAngularVelocity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_IsSleeping, PxRigidDynamic, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SleepThreshold, PxRigidDynamic, PxReal, PxReal > SleepThreshold;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SolverIterationCounts, PxRigidDynamic, PxU32 > SolverIterationCounts;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_ContactReportThreshold, PxRigidDynamic, PxReal, PxReal > ContactReportThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_RigidDynamicFlags, PxRigidDynamic, PxRigidDynamicFlags, PxRigidDynamicFlags > RigidDynamicFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_ConcreteTypeName, PxRigidDynamic, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxRigidDynamicGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidDynamic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 10; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( KinematicTarget, inStartIndex + 0 );; 
			inOperator( LinearDamping, inStartIndex + 1 );; 
			inOperator( AngularDamping, inStartIndex + 2 );; 
			inOperator( MaxAngularVelocity, inStartIndex + 3 );; 
			inOperator( IsSleeping, inStartIndex + 4 );; 
			inOperator( SleepThreshold, inStartIndex + 5 );; 
			inOperator( SolverIterationCounts, inStartIndex + 6 );; 
			inOperator( ContactReportThreshold, inStartIndex + 7 );; 
			inOperator( RigidDynamicFlags, inStartIndex + 8 );; 
			inOperator( ConcreteTypeName, inStartIndex + 9 );; 
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidDynamic> { PxRigidDynamicGeneratedInfo Info; };

	class PxRigidStatic;
	struct PxRigidStaticGeneratedValues
		: PxRigidActorGeneratedValues	{
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxRigidStaticGeneratedValues( const PxRigidStatic* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidStatic, ConcreteTypeName, PxRigidStaticGeneratedValues)
	struct PxRigidStaticGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidStatic"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidStatic_ConcreteTypeName, PxRigidStatic, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxRigidStaticGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidStatic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ConcreteTypeName, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidStatic> { PxRigidStaticGeneratedInfo Info; };

	class PxArticulationLink;
	struct PxArticulationLinkGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxArticulationJoint * InboundJoint;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxArticulationLinkGeneratedValues( const PxArticulationLink* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationLink, InboundJoint, PxArticulationLinkGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationLink, ConcreteTypeName, PxArticulationLinkGeneratedValues)
	struct PxArticulationLinkGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxArticulationLink"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_InboundJoint, PxArticulationLink, PxArticulationJoint * > InboundJoint;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_Children, PxArticulationLink, PxArticulationLink * > Children;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_ConcreteTypeName, PxArticulationLink, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxArticulationLinkGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulationLink*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( InboundJoint, inStartIndex + 0 );; 
			inOperator( Children, inStartIndex + 1 );; 
			inOperator( ConcreteTypeName, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationLink> { PxArticulationLinkGeneratedInfo Info; };

	class PxArticulationJoint;
	struct PxArticulationJointGeneratedValues
	{
		PxTransform ParentPose;
		PxTransform ChildPose;
		PxQuat TargetOrientation;
		PxVec3 TargetVelocity;
		PxReal Spring;
		PxReal Damping;
		PxReal InternalCompliance;
		PxReal ExternalCompliance;
		PxReal SwingLimit[2];
		PxReal TangentialSpring;
		PxReal TangentialDamping;
		PxReal SwingLimitContactDistance;
		_Bool SwingLimitEnabled;
		PxReal TwistLimit[2];
		_Bool TwistLimitEnabled;
		PxReal TwistLimitContactDistance;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxArticulationJointGeneratedValues( const PxArticulationJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ParentPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ChildPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetOrientation, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetVelocity, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Spring, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Damping, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, InternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ExternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TangentialSpring, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TangentialDamping, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimitContactDistance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimitEnabled, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimitEnabled, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimitContactDistance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ConcreteTypeName, PxArticulationJointGeneratedValues)
	struct PxArticulationJointGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulationJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ParentPose, PxArticulationJoint, const PxTransform &, PxTransform > ParentPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ChildPose, PxArticulationJoint, const PxTransform &, PxTransform > ChildPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetOrientation, PxArticulationJoint, const PxQuat &, PxQuat > TargetOrientation;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetVelocity, PxArticulationJoint, const PxVec3 &, PxVec3 > TargetVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Spring, PxArticulationJoint, PxReal, PxReal > Spring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Damping, PxArticulationJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_InternalCompliance, PxArticulationJoint, PxReal, PxReal > InternalCompliance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ExternalCompliance, PxArticulationJoint, PxReal, PxReal > ExternalCompliance;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimit, PxArticulationJoint, PxReal > SwingLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TangentialSpring, PxArticulationJoint, PxReal, PxReal > TangentialSpring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TangentialDamping, PxArticulationJoint, PxReal, PxReal > TangentialDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimitContactDistance, PxArticulationJoint, PxReal, PxReal > SwingLimitContactDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimitEnabled, PxArticulationJoint, _Bool, _Bool > SwingLimitEnabled;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimit, PxArticulationJoint, PxReal > TwistLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimitEnabled, PxArticulationJoint, _Bool, _Bool > TwistLimitEnabled;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimitContactDistance, PxArticulationJoint, PxReal, PxReal > TwistLimitContactDistance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ConcreteTypeName, PxArticulationJoint, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxArticulationJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulationJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 17; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ParentPose, inStartIndex + 0 );; 
			inOperator( ChildPose, inStartIndex + 1 );; 
			inOperator( TargetOrientation, inStartIndex + 2 );; 
			inOperator( TargetVelocity, inStartIndex + 3 );; 
			inOperator( Spring, inStartIndex + 4 );; 
			inOperator( Damping, inStartIndex + 5 );; 
			inOperator( InternalCompliance, inStartIndex + 6 );; 
			inOperator( ExternalCompliance, inStartIndex + 7 );; 
			inOperator( SwingLimit, inStartIndex + 8 );; 
			inOperator( TangentialSpring, inStartIndex + 9 );; 
			inOperator( TangentialDamping, inStartIndex + 10 );; 
			inOperator( SwingLimitContactDistance, inStartIndex + 11 );; 
			inOperator( SwingLimitEnabled, inStartIndex + 12 );; 
			inOperator( TwistLimit, inStartIndex + 13 );; 
			inOperator( TwistLimitEnabled, inStartIndex + 14 );; 
			inOperator( TwistLimitContactDistance, inStartIndex + 15 );; 
			inOperator( ConcreteTypeName, inStartIndex + 16 );; 
			return 17 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationJoint> { PxArticulationJointGeneratedInfo Info; };

	class PxArticulation;
	struct PxArticulationGeneratedValues
	{
		PxScene * Scene;
		PxU32 MaxProjectionIterations;
		PxReal SeparationTolerance;
		PxU32 InternalDriveIterations;
		PxU32 ExternalDriveIterations;
		PxU32 SolverIterationCounts[2];
		_Bool IsSleeping;
		PxReal SleepThreshold;
		const char * Name;
		PxBounds3 WorldBounds;
		PxAggregate * Aggregate;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxArticulationGeneratedValues( const PxArticulation* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Scene, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, MaxProjectionIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SeparationTolerance, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, InternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, ExternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SolverIterationCounts, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, IsSleeping, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SleepThreshold, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Name, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, WorldBounds, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Aggregate, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, ConcreteTypeName, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, UserData, PxArticulationGeneratedValues)
	struct PxArticulationGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulation"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Scene, PxArticulation, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_MaxProjectionIterations, PxArticulation, PxU32, PxU32 > MaxProjectionIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SeparationTolerance, PxArticulation, PxReal, PxReal > SeparationTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_InternalDriveIterations, PxArticulation, PxU32, PxU32 > InternalDriveIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_ExternalDriveIterations, PxArticulation, PxU32, PxU32 > ExternalDriveIterations;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SolverIterationCounts, PxArticulation, PxU32 > SolverIterationCounts;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_IsSleeping, PxArticulation, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SleepThreshold, PxArticulation, PxReal, PxReal > SleepThreshold;
		PxArticulationLinkCollectionProp Links;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Name, PxArticulation, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_WorldBounds, PxArticulation, PxBounds3 > WorldBounds;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Aggregate, PxArticulation, PxAggregate * > Aggregate;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_ConcreteTypeName, PxArticulation, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_UserData, PxArticulation, void *, void * > UserData;

		PX_PHYSX_CORE_API PxArticulationGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulation*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 14; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( MaxProjectionIterations, inStartIndex + 1 );; 
			inOperator( SeparationTolerance, inStartIndex + 2 );; 
			inOperator( InternalDriveIterations, inStartIndex + 3 );; 
			inOperator( ExternalDriveIterations, inStartIndex + 4 );; 
			inOperator( SolverIterationCounts, inStartIndex + 5 );; 
			inOperator( IsSleeping, inStartIndex + 6 );; 
			inOperator( SleepThreshold, inStartIndex + 7 );; 
			inOperator( Links, inStartIndex + 8 );; 
			inOperator( Name, inStartIndex + 9 );; 
			inOperator( WorldBounds, inStartIndex + 10 );; 
			inOperator( Aggregate, inStartIndex + 11 );; 
			inOperator( ConcreteTypeName, inStartIndex + 12 );; 
			inOperator( UserData, inStartIndex + 13 );; 
			return 14 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulation> { PxArticulationGeneratedInfo Info; };

	class PxAggregate;
	struct PxAggregateGeneratedValues
	{
		PxU32 MaxNbActors;
		_Bool SelfCollision;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxAggregateGeneratedValues( const PxAggregate* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, MaxNbActors, PxAggregateGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, SelfCollision, PxAggregateGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxAggregate, ConcreteTypeName, PxAggregateGeneratedValues)
	struct PxAggregateGeneratedInfo

	{
		static const char* getClassName() { return "PxAggregate"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_MaxNbActors, PxAggregate, PxU32 > MaxNbActors;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_Actors, PxAggregate, PxActor * > Actors;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_SelfCollision, PxAggregate, _Bool > SelfCollision;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxAggregate_ConcreteTypeName, PxAggregate, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxAggregateGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxAggregate*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( MaxNbActors, inStartIndex + 0 );; 
			inOperator( Actors, inStartIndex + 1 );; 
			inOperator( SelfCollision, inStartIndex + 2 );; 
			inOperator( ConcreteTypeName, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxAggregate> { PxAggregateGeneratedInfo Info; };

	static PxU32ToName g_physx__PxConstraintFlag__TypeConversion[] = {
		{ "eBROKEN", static_cast<PxU32>( physx::PxConstraintFlag::eBROKEN ) },
		{ "ePROJECTION", static_cast<PxU32>( physx::PxConstraintFlag::ePROJECTION ) },
		{ "eCOLLISION_ENABLED", static_cast<PxU32>( physx::PxConstraintFlag::eCOLLISION_ENABLED ) },
		{ "eREPORTING", static_cast<PxU32>( physx::PxConstraintFlag::eREPORTING ) },
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxConstraintFlag::eVISUALIZATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxConstraintFlag::Type > { PxEnumTraits() : NameConversion( g_physx__PxConstraintFlag__TypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxConstraint;
	struct PxConstraintGeneratedValues
	{
		PxScene * Scene;
		PxRigidActor * Actors[2];
		PxConstraintFlags Flags;
		PxReal BreakForce[2];
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxConstraintGeneratedValues( const PxConstraint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Scene, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Actors, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Flags, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, BreakForce, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, ConcreteTypeName, PxConstraintGeneratedValues)
	struct PxConstraintGeneratedInfo

	{
		static const char* getClassName() { return "PxConstraint"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Scene, PxConstraint, PxScene * > Scene;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Actors, PxConstraint, PxRigidActor * > Actors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Flags, PxConstraint, PxConstraintFlags, PxConstraintFlags > Flags;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_BreakForce, PxConstraint, PxReal > BreakForce;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_ConcreteTypeName, PxConstraint, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxConstraintGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxConstraint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( Actors, inStartIndex + 1 );; 
			inOperator( Flags, inStartIndex + 2 );; 
			inOperator( BreakForce, inStartIndex + 3 );; 
			inOperator( ConcreteTypeName, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConstraint> { PxConstraintGeneratedInfo Info; };

	static PxU32ToName g_physx__PxGeometryType__EnumConversion[] = {
		{ "eSPHERE", static_cast<PxU32>( physx::PxGeometryType::eSPHERE ) },
		{ "ePLANE", static_cast<PxU32>( physx::PxGeometryType::ePLANE ) },
		{ "eCAPSULE", static_cast<PxU32>( physx::PxGeometryType::eCAPSULE ) },
		{ "eBOX", static_cast<PxU32>( physx::PxGeometryType::eBOX ) },
		{ "eCONVEXMESH", static_cast<PxU32>( physx::PxGeometryType::eCONVEXMESH ) },
		{ "eTRIANGLEMESH", static_cast<PxU32>( physx::PxGeometryType::eTRIANGLEMESH ) },
		{ "eHEIGHTFIELD", static_cast<PxU32>( physx::PxGeometryType::eHEIGHTFIELD ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxGeometryType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxGeometryType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxShapeFlag__EnumConversion[] = {
		{ "eSIMULATION_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eSIMULATION_SHAPE ) },
		{ "eSCENE_QUERY_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eSCENE_QUERY_SHAPE ) },
		{ "eTRIGGER_SHAPE", static_cast<PxU32>( physx::PxShapeFlag::eTRIGGER_SHAPE ) },
		{ "eVISUALIZATION", static_cast<PxU32>( physx::PxShapeFlag::eVISUALIZATION ) },
		{ "ePARTICLE_DRAIN", static_cast<PxU32>( physx::PxShapeFlag::ePARTICLE_DRAIN ) },
		{ "eUSE_SWEPT_BOUNDS", static_cast<PxU32>( physx::PxShapeFlag::eUSE_SWEPT_BOUNDS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxShapeFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxShapeFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxSceneQueryFlag__EnumConversion[] = {
		{ "eIMPACT", static_cast<PxU32>( physx::PxSceneQueryFlag::eIMPACT ) },
		{ "eNORMAL", static_cast<PxU32>( physx::PxSceneQueryFlag::eNORMAL ) },
		{ "eDISTANCE", static_cast<PxU32>( physx::PxSceneQueryFlag::eDISTANCE ) },
		{ "eUV", static_cast<PxU32>( physx::PxSceneQueryFlag::eUV ) },
		{ "eINITIAL_OVERLAP", static_cast<PxU32>( physx::PxSceneQueryFlag::eINITIAL_OVERLAP ) },
		{ "eINITIAL_OVERLAP_KEEP", static_cast<PxU32>( physx::PxSceneQueryFlag::eINITIAL_OVERLAP_KEEP ) },
		{ "eTOUCHING_HIT", static_cast<PxU32>( physx::PxSceneQueryFlag::eTOUCHING_HIT ) },
		{ "eBLOCKING_HIT", static_cast<PxU32>( physx::PxSceneQueryFlag::eBLOCKING_HIT ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSceneQueryFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSceneQueryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxShape;
	struct PxShapeGeneratedValues
	{
		PxGeometryType::Enum GeometryType;
		PxGeometryHolder Geometry;
		PxBounds3 WorldBounds;
		PxTransform LocalPose;
		PxFilterData SimulationFilterData;
		PxFilterData QueryFilterData;
		PxReal ContactOffset;
		PxReal RestOffset;
		PxShapeFlags Flags;
		const char * Name;
		const char * ConcreteTypeName;
		void * UserData;
		 PX_PHYSX_CORE_API PxShapeGeneratedValues( const PxShape* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, GeometryType, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Geometry, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, WorldBounds, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, LocalPose, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, SimulationFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, QueryFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, ContactOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, RestOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Flags, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Name, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, ConcreteTypeName, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, UserData, PxShapeGeneratedValues)
	struct PxShapeGeneratedInfo

	{
		static const char* getClassName() { return "PxShape"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_GeometryType, PxShape, PxGeometryType::Enum > GeometryType;
		PxShapeGeometryProperty Geometry;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_WorldBounds, PxShape, PxBounds3 > WorldBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_LocalPose, PxShape, const PxTransform &, PxTransform > LocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_SimulationFilterData, PxShape, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_QueryFilterData, PxShape, const PxFilterData &, PxFilterData > QueryFilterData;
		PxShapeMaterialsProperty Materials;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_ContactOffset, PxShape, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_RestOffset, PxShape, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Flags, PxShape, PxShapeFlags, PxShapeFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Name, PxShape, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_ConcreteTypeName, PxShape, const char * > ConcreteTypeName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_UserData, PxShape, void *, void * > UserData;

		PX_PHYSX_CORE_API PxShapeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxShape*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 13; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( GeometryType, inStartIndex + 0 );; 
			inOperator( Geometry, inStartIndex + 1 );; 
			inOperator( WorldBounds, inStartIndex + 2 );; 
			inOperator( LocalPose, inStartIndex + 3 );; 
			inOperator( SimulationFilterData, inStartIndex + 4 );; 
			inOperator( QueryFilterData, inStartIndex + 5 );; 
			inOperator( Materials, inStartIndex + 6 );; 
			inOperator( ContactOffset, inStartIndex + 7 );; 
			inOperator( RestOffset, inStartIndex + 8 );; 
			inOperator( Flags, inStartIndex + 9 );; 
			inOperator( Name, inStartIndex + 10 );; 
			inOperator( ConcreteTypeName, inStartIndex + 11 );; 
			inOperator( UserData, inStartIndex + 12 );; 
			return 13 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxShape> { PxShapeGeneratedInfo Info; };

	static PxU32ToName g_physx__PxClothFabricPhaseType__EnumConversion[] = {
		{ "eSTRETCHING", static_cast<PxU32>( physx::PxClothFabricPhaseType::eSTRETCHING ) },
		{ "eSTRETCHING_HORIZONTAL", static_cast<PxU32>( physx::PxClothFabricPhaseType::eSTRETCHING_HORIZONTAL ) },
		{ "eBENDING", static_cast<PxU32>( physx::PxClothFabricPhaseType::eBENDING ) },
		{ "eSHEARING", static_cast<PxU32>( physx::PxClothFabricPhaseType::eSHEARING ) },
		{ "eZEROSTRETCH", static_cast<PxU32>( physx::PxClothFabricPhaseType::eZEROSTRETCH ) },
		{ "eBENDING_ANGLE", static_cast<PxU32>( physx::PxClothFabricPhaseType::eBENDING_ANGLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxClothFabricPhaseType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxClothFabricPhaseType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxClothFabric;
	struct PxClothFabricGeneratedValues
	{
		PxU32 NbParticles;
		PxU32 ReferenceCount;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxClothFabricGeneratedValues( const PxClothFabric* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, NbParticles, PxClothFabricGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, ReferenceCount, PxClothFabricGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothFabric, ConcreteTypeName, PxClothFabricGeneratedValues)
	struct PxClothFabricGeneratedInfo

	{
		static const char* getClassName() { return "PxClothFabric"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_NbParticles, PxClothFabric, PxU32 > NbParticles;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Phases, PxClothFabric, PxU32 > Phases;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Sets, PxClothFabric, PxU32 > Sets;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Fibers, PxClothFabric, PxU32 > Fibers;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ParticleIndices, PxClothFabric, PxU32 > ParticleIndices;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_Restvalues, PxClothFabric, PxReal > Restvalues;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ReferenceCount, PxClothFabric, PxU32 > ReferenceCount;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothFabric_ConcreteTypeName, PxClothFabric, const char * > ConcreteTypeName;
		PhaseTypesProperty PhaseTypes;

		PX_PHYSX_CORE_API PxClothFabricGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxClothFabric*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NbParticles, inStartIndex + 0 );; 
			inOperator( Phases, inStartIndex + 1 );; 
			inOperator( Sets, inStartIndex + 2 );; 
			inOperator( Fibers, inStartIndex + 3 );; 
			inOperator( ParticleIndices, inStartIndex + 4 );; 
			inOperator( Restvalues, inStartIndex + 5 );; 
			inOperator( ReferenceCount, inStartIndex + 6 );; 
			inOperator( ConcreteTypeName, inStartIndex + 7 );; 
			inOperator( PhaseTypes, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothFabric> { PxClothFabricGeneratedInfo Info; };

	static PxU32ToName g_physx__PxClothFlag__EnumConversion[] = {
		{ "eSWEPT_CONTACT", static_cast<PxU32>( physx::PxClothFlag::eSWEPT_CONTACT ) },
		{ "eGPU", static_cast<PxU32>( physx::PxClothFlag::eGPU ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxClothFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxClothFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxCloth;
	struct PxClothGeneratedValues
		: PxActorGeneratedValues	{
		PxU32 NbParticles;
		PxReal MotionConstraintScaleBias[2];
		PxTransform GlobalPose;
		PxReal InertiaScale;
		PxVec3 ExternalAcceleration;
		PxReal DampingCoefficient;
		PxReal FrictionCoefficient;
		PxReal DragCoefficient;
		PxReal CollisionMassScale;
		PxReal SolverFrequency;
		PxClothFlags ClothFlags;
		_Bool IsSleeping;
		PxReal SleepLinearVelocity;
		PxReal PreviousTimeStep;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxClothGeneratedValues( const PxCloth* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, NbParticles, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, MotionConstraintScaleBias, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, GlobalPose, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, InertiaScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ExternalAcceleration, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, DampingCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, FrictionCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, DragCoefficient, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, CollisionMassScale, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SolverFrequency, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ClothFlags, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, IsSleeping, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, SleepLinearVelocity, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, PreviousTimeStep, PxClothGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCloth, ConcreteTypeName, PxClothGeneratedValues)
	struct PxClothGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxCloth"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_NbParticles, PxCloth, PxU32 > NbParticles;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_MotionConstraintScaleBias, PxCloth, PxReal > MotionConstraintScaleBias;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_CollisionSpheres, PxCloth, const PxClothCollisionSphere * > CollisionSpheres;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_CollisionPlanes, PxCloth, const PxClothCollisionPlane * > CollisionPlanes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_GlobalPose, PxCloth, const PxTransform &, PxTransform > GlobalPose;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_TargetPose, PxCloth, const PxTransform & > TargetPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_InertiaScale, PxCloth, PxReal, PxReal > InertiaScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ExternalAcceleration, PxCloth, PxVec3, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_DampingCoefficient, PxCloth, PxReal, PxReal > DampingCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_FrictionCoefficient, PxCloth, PxReal, PxReal > FrictionCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_DragCoefficient, PxCloth, PxReal, PxReal > DragCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_CollisionMassScale, PxCloth, PxReal, PxReal > CollisionMassScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SolverFrequency, PxCloth, PxReal, PxReal > SolverFrequency;
		PhaseSolverConfigProperty PhaseSolverConfig;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ClothFlags, PxCloth, PxClothFlags > ClothFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_IsSleeping, PxCloth, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_SleepLinearVelocity, PxCloth, PxReal, PxReal > SleepLinearVelocity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_PreviousTimeStep, PxCloth, PxReal > PreviousTimeStep;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCloth_ConcreteTypeName, PxCloth, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxClothGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxCloth*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 19; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NbParticles, inStartIndex + 0 );; 
			inOperator( MotionConstraintScaleBias, inStartIndex + 1 );; 
			inOperator( CollisionSpheres, inStartIndex + 2 );; 
			inOperator( CollisionPlanes, inStartIndex + 3 );; 
			inOperator( GlobalPose, inStartIndex + 4 );; 
			inOperator( TargetPose, inStartIndex + 5 );; 
			inOperator( InertiaScale, inStartIndex + 6 );; 
			inOperator( ExternalAcceleration, inStartIndex + 7 );; 
			inOperator( DampingCoefficient, inStartIndex + 8 );; 
			inOperator( FrictionCoefficient, inStartIndex + 9 );; 
			inOperator( DragCoefficient, inStartIndex + 10 );; 
			inOperator( CollisionMassScale, inStartIndex + 11 );; 
			inOperator( SolverFrequency, inStartIndex + 12 );; 
			inOperator( PhaseSolverConfig, inStartIndex + 13 );; 
			inOperator( ClothFlags, inStartIndex + 14 );; 
			inOperator( IsSleeping, inStartIndex + 15 );; 
			inOperator( SleepLinearVelocity, inStartIndex + 16 );; 
			inOperator( PreviousTimeStep, inStartIndex + 17 );; 
			inOperator( ConcreteTypeName, inStartIndex + 18 );; 
			return 19 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCloth> { PxClothGeneratedInfo Info; };

	static PxU32ToName g_physx__PxParticleBaseFlag__EnumConversion[] = {
		{ "eCOLLISION_TWOWAY", static_cast<PxU32>( physx::PxParticleBaseFlag::eCOLLISION_TWOWAY ) },
		{ "eCOLLISION_WITH_DYNAMIC_ACTORS", static_cast<PxU32>( physx::PxParticleBaseFlag::eCOLLISION_WITH_DYNAMIC_ACTORS ) },
		{ "eENABLED", static_cast<PxU32>( physx::PxParticleBaseFlag::eENABLED ) },
		{ "ePROJECT_TO_PLANE", static_cast<PxU32>( physx::PxParticleBaseFlag::ePROJECT_TO_PLANE ) },
		{ "ePER_PARTICLE_REST_OFFSET", static_cast<PxU32>( physx::PxParticleBaseFlag::ePER_PARTICLE_REST_OFFSET ) },
		{ "ePER_PARTICLE_COLLISION_CACHE_HINT", static_cast<PxU32>( physx::PxParticleBaseFlag::ePER_PARTICLE_COLLISION_CACHE_HINT ) },
		{ "eGPU", static_cast<PxU32>( physx::PxParticleBaseFlag::eGPU ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxParticleBaseFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxParticleBaseFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxParticleReadDataFlag__EnumConversion[] = {
		{ "ePOSITION_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::ePOSITION_BUFFER ) },
		{ "eVELOCITY_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eVELOCITY_BUFFER ) },
		{ "eREST_OFFSET_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eREST_OFFSET_BUFFER ) },
		{ "eFLAGS_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eFLAGS_BUFFER ) },
		{ "eCOLLISION_NORMAL_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eCOLLISION_NORMAL_BUFFER ) },
		{ "eDENSITY_BUFFER", static_cast<PxU32>( physx::PxParticleReadDataFlag::eDENSITY_BUFFER ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxParticleReadDataFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxParticleReadDataFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxParticleBase;
	struct PxParticleBaseGeneratedValues
		: PxActorGeneratedValues	{
		PxReal Damping;
		PxVec3 ExternalAcceleration;
		PxReal ParticleMass;
		PxReal Restitution;
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxFilterData SimulationFilterData;
		PxParticleBaseFlags ParticleBaseFlags;
		PxU32 MaxParticles;
		PxReal MaxMotionDistance;
		PxReal RestOffset;
		PxReal ContactOffset;
		PxReal GridSize;
		PxParticleReadDataFlags ParticleReadDataFlags;
		PxMetaDataPlane ProjectionPlane;
		 PX_PHYSX_CORE_API PxParticleBaseGeneratedValues( const PxParticleBase* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Damping, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ExternalAcceleration, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleMass, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Restitution, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, DynamicFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, StaticFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, SimulationFilterData, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleBaseFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxParticles, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxMotionDistance, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, RestOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ContactOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, GridSize, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleReadDataFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ProjectionPlane, PxParticleBaseGeneratedValues)
	struct PxParticleBaseGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleBase"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Damping, PxParticleBase, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ExternalAcceleration, PxParticleBase, const PxVec3 &, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleMass, PxParticleBase, PxReal, PxReal > ParticleMass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Restitution, PxParticleBase, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_DynamicFriction, PxParticleBase, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_StaticFriction, PxParticleBase, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_SimulationFilterData, PxParticleBase, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleBaseFlags, PxParticleBase, PxParticleBaseFlags > ParticleBaseFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxParticles, PxParticleBase, PxU32 > MaxParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxMotionDistance, PxParticleBase, PxReal, PxReal > MaxMotionDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_RestOffset, PxParticleBase, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ContactOffset, PxParticleBase, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_GridSize, PxParticleBase, PxReal, PxReal > GridSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleReadDataFlags, PxParticleBase, PxParticleReadDataFlags > ParticleReadDataFlags;
		ProjectionPlaneProperty ProjectionPlane;

		PX_PHYSX_CORE_API PxParticleBaseGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleBase*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 15; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Damping, inStartIndex + 0 );; 
			inOperator( ExternalAcceleration, inStartIndex + 1 );; 
			inOperator( ParticleMass, inStartIndex + 2 );; 
			inOperator( Restitution, inStartIndex + 3 );; 
			inOperator( DynamicFriction, inStartIndex + 4 );; 
			inOperator( StaticFriction, inStartIndex + 5 );; 
			inOperator( SimulationFilterData, inStartIndex + 6 );; 
			inOperator( ParticleBaseFlags, inStartIndex + 7 );; 
			inOperator( MaxParticles, inStartIndex + 8 );; 
			inOperator( MaxMotionDistance, inStartIndex + 9 );; 
			inOperator( RestOffset, inStartIndex + 10 );; 
			inOperator( ContactOffset, inStartIndex + 11 );; 
			inOperator( GridSize, inStartIndex + 12 );; 
			inOperator( ParticleReadDataFlags, inStartIndex + 13 );; 
			inOperator( ProjectionPlane, inStartIndex + 14 );; 
			return 15 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleBase> { PxParticleBaseGeneratedInfo Info; };

	class PxParticleFluid;
	struct PxParticleFluidGeneratedValues
		: PxParticleBaseGeneratedValues	{
		PxReal Stiffness;
		PxReal Viscosity;
		PxReal RestParticleDistance;
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxParticleFluidGeneratedValues( const PxParticleFluid* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Stiffness, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Viscosity, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, RestParticleDistance, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, ConcreteTypeName, PxParticleFluidGeneratedValues)
	struct PxParticleFluidGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleFluid"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Stiffness, PxParticleFluid, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Viscosity, PxParticleFluid, PxReal, PxReal > Viscosity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_RestParticleDistance, PxParticleFluid, PxReal, PxReal > RestParticleDistance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_ConcreteTypeName, PxParticleFluid, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxParticleFluidGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleFluid*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Stiffness, inStartIndex + 0 );; 
			inOperator( Viscosity, inStartIndex + 1 );; 
			inOperator( RestParticleDistance, inStartIndex + 2 );; 
			inOperator( ConcreteTypeName, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleFluid> { PxParticleFluidGeneratedInfo Info; };

	class PxParticleSystem;
	struct PxParticleSystemGeneratedValues
		: PxParticleBaseGeneratedValues	{
		const char * ConcreteTypeName;
		 PX_PHYSX_CORE_API PxParticleSystemGeneratedValues( const PxParticleSystem* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleSystem, ConcreteTypeName, PxParticleSystemGeneratedValues)
	struct PxParticleSystemGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleSystem"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleSystem_ConcreteTypeName, PxParticleSystem, const char * > ConcreteTypeName;

		PX_PHYSX_CORE_API PxParticleSystemGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleSystem*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ConcreteTypeName, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleSystem> { PxParticleSystemGeneratedInfo Info; };

	class PxPhysics;
	struct PxPhysicsGeneratedValues
	{
		PxTolerancesScale TolerancesScale;
		 PX_PHYSX_CORE_API PxPhysicsGeneratedValues( const PxPhysics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPhysics, TolerancesScale, PxPhysicsGeneratedValues)
	struct PxPhysicsGeneratedInfo

	{
		static const char* getClassName() { return "PxPhysics"; }
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_Scenes, PxPhysics, PxScene *, const PxSceneDesc & > Scenes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_Materials, PxPhysics, PxMaterial * > Materials;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_TriangleMeshes, PxPhysics, PxTriangleMesh *, PxInputStream & > TriangleMeshes;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_HeightFields, PxPhysics, PxHeightField *, const PxHeightFieldDesc & > HeightFields;
		PxFactoryCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_ConvexMeshes, PxPhysics, PxConvexMesh *, PxInputStream & > ConvexMeshes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_ClothFabrics, PxPhysics, PxClothFabric * > ClothFabrics;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_TolerancesScale, PxPhysics, const PxTolerancesScale & > TolerancesScale;

		PX_PHYSX_CORE_API PxPhysicsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxPhysics*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 7; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scenes, inStartIndex + 0 );; 
			inOperator( Materials, inStartIndex + 1 );; 
			inOperator( TriangleMeshes, inStartIndex + 2 );; 
			inOperator( HeightFields, inStartIndex + 3 );; 
			inOperator( ConvexMeshes, inStartIndex + 4 );; 
			inOperator( ClothFabrics, inStartIndex + 5 );; 
			inOperator( TolerancesScale, inStartIndex + 6 );; 
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPhysics> { PxPhysicsGeneratedInfo Info; };

	class PxTolerancesScale;
	struct PxTolerancesScaleGeneratedValues
	{
		_Bool IsValid;
		PxReal Length;
		PxReal Mass;
		PxReal Speed;
		 PX_PHYSX_CORE_API PxTolerancesScaleGeneratedValues( const PxTolerancesScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, IsValid, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Length, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Mass, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Speed, PxTolerancesScaleGeneratedValues)
	struct PxTolerancesScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxTolerancesScale"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_IsValid, PxTolerancesScale, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Length, PxTolerancesScale, PxReal, PxReal > Length;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Mass, PxTolerancesScale, PxReal, PxReal > Mass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Speed, PxTolerancesScale, PxReal, PxReal > Speed;

		PX_PHYSX_CORE_API PxTolerancesScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxTolerancesScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Length, inStartIndex + 1 );; 
			inOperator( Mass, inStartIndex + 2 );; 
			inOperator( Speed, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTolerancesScale> { PxTolerancesScaleGeneratedInfo Info; };

	static PxU32ToName g_physx__PxSceneFlag__EnumConversion[] = {
		{ "eDISABLE_SSE", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_SSE ) },
		{ "eENABLE_ACTIVETRANSFORMS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_ACTIVETRANSFORMS ) },
		{ "eENABLE_SWEPT_INTEGRATION", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_SWEPT_INTEGRATION ) },
		{ "eADAPTIVE_FORCE", static_cast<PxU32>( physx::PxSceneFlag::eADAPTIVE_FORCE ) },
		{ "eENABLE_KINEMATIC_STATIC_PAIRS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS ) },
		{ "eENABLE_KINEMATIC_PAIRS", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_KINEMATIC_PAIRS ) },
		{ "eENABLE_ONE_DIRECTIONAL_FRICTION", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_ONE_DIRECTIONAL_FRICTION ) },
		{ "eENABLE_TWO_DIRECTIONAL_FRICTION", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_TWO_DIRECTIONAL_FRICTION ) },
		{ "eENABLE_PCM", static_cast<PxU32>( physx::PxSceneFlag::eENABLE_PCM ) },
		{ "eDISABLE_CONTACT_REPORT_BUFFER_RESIZE", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE ) },
		{ "eDISABLE_CONTACT_CACHE", static_cast<PxU32>( physx::PxSceneFlag::eDISABLE_CONTACT_CACHE ) },
		{ "eREQUIRE_RW_LOCK", static_cast<PxU32>( physx::PxSceneFlag::eREQUIRE_RW_LOCK ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSceneFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSceneFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxActorTypeSelectionFlag__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( physx::PxActorTypeSelectionFlag::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( physx::PxActorTypeSelectionFlag::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxActorTypeSelectionFlag::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( physx::PxActorTypeSelectionFlag::ePARTICLE_FLUID ) },
		{ "eCLOTH", static_cast<PxU32>( physx::PxActorTypeSelectionFlag::eCLOTH ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxActorTypeSelectionFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxActorTypeSelectionFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxSceneQueryFilterFlag__EnumConversion[] = {
		{ "eSTATIC", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::eSTATIC ) },
		{ "eDYNAMIC", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::eDYNAMIC ) },
		{ "ePREFILTER", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::ePREFILTER ) },
		{ "ePOSTFILTER", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::ePOSTFILTER ) },
		{ "eMESH_MULTIPLE", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::eMESH_MULTIPLE ) },
		{ "eBACKFACE", static_cast<PxU32>( physx::PxSceneQueryFilterFlag::eBACKFACE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSceneQueryFilterFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSceneQueryFilterFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxVisualizationParameter__EnumConversion[] = {
		{ "eSCALE", static_cast<PxU32>( physx::PxVisualizationParameter::eSCALE ) },
		{ "eWORLD_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eWORLD_AXES ) },
		{ "eBODY_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_AXES ) },
		{ "eBODY_MASS_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_MASS_AXES ) },
		{ "eBODY_LIN_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_LIN_VELOCITY ) },
		{ "eBODY_ANG_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_ANG_VELOCITY ) },
		{ "eBODY_JOINT_GROUPS", static_cast<PxU32>( physx::PxVisualizationParameter::eBODY_JOINT_GROUPS ) },
		{ "eCONTACT_POINT", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_POINT ) },
		{ "eCONTACT_NORMAL", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_NORMAL ) },
		{ "eCONTACT_ERROR", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_ERROR ) },
		{ "eCONTACT_FORCE", static_cast<PxU32>( physx::PxVisualizationParameter::eCONTACT_FORCE ) },
		{ "eACTOR_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eACTOR_AXES ) },
		{ "eCOLLISION_AABBS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_AABBS ) },
		{ "eCOLLISION_SHAPES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_SHAPES ) },
		{ "eCOLLISION_AXES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_AXES ) },
		{ "eCOLLISION_COMPOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_COMPOUNDS ) },
		{ "eCOLLISION_FNORMALS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_FNORMALS ) },
		{ "eCOLLISION_EDGES", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_EDGES ) },
		{ "eCOLLISION_STATIC", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_STATIC ) },
		{ "eCOLLISION_DYNAMIC", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_DYNAMIC ) },
		{ "eCOLLISION_PAIRS", static_cast<PxU32>( physx::PxVisualizationParameter::eCOLLISION_PAIRS ) },
		{ "eJOINT_LOCAL_FRAMES", static_cast<PxU32>( physx::PxVisualizationParameter::eJOINT_LOCAL_FRAMES ) },
		{ "eJOINT_LIMITS", static_cast<PxU32>( physx::PxVisualizationParameter::eJOINT_LIMITS ) },
		{ "ePARTICLE_SYSTEM_POSITION", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_POSITION ) },
		{ "ePARTICLE_SYSTEM_VELOCITY", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_VELOCITY ) },
		{ "ePARTICLE_SYSTEM_COLLISION_NORMAL", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_COLLISION_NORMAL ) },
		{ "ePARTICLE_SYSTEM_BOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_GRID", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_GRID ) },
		{ "ePARTICLE_SYSTEM_BROADPHASE_BOUNDS", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_BROADPHASE_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE", static_cast<PxU32>( physx::PxVisualizationParameter::ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE ) },
		{ "eCULL_BOX", static_cast<PxU32>( physx::PxVisualizationParameter::eCULL_BOX ) },
		{ "eNUM_VALUES", static_cast<PxU32>( physx::PxVisualizationParameter::eNUM_VALUES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxVisualizationParameter::Enum > { PxEnumTraits() : NameConversion( g_physx__PxVisualizationParameter__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxScene;
	struct PxSceneGeneratedValues
	{
		PxSceneFlags Flags;
		PxVec3 Gravity;
		PxU32 Timestamp;
		PxU32 SceneQueryStaticTimestamp;
		PxReal BounceThresholdVelocity;
		physx::pxtask::TaskManager * TaskManager;
		PxU32 SolverBatchSize;
		PxU32 MaxNbContactDataBlocksUsed;
		PxContactModifyCallback * ContactModifyCallback;
		const void * FilterShaderData;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxU32 DynamicTreeRebuildRateHint;
		PxBounds3 VisualizationCullingBox;
		void * UserData;
		PxSimulationStatistics SimulationStatistics;
		 PX_PHYSX_CORE_API PxSceneGeneratedValues( const PxScene* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Flags, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Gravity, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Timestamp, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SceneQueryStaticTimestamp, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, BounceThresholdVelocity, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, TaskManager, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SolverBatchSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, MaxNbContactDataBlocksUsed, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ContactModifyCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShaderData, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShaderDataSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShader, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, DynamicTreeRebuildRateHint, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, VisualizationCullingBox, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, UserData, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SimulationStatistics, PxSceneGeneratedValues)
	struct PxSceneGeneratedInfo

	{
		static const char* getClassName() { return "PxScene"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Flags, PxScene, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Gravity, PxScene, const PxVec3 &, PxVec3 > Gravity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Timestamp, PxScene, PxU32 > Timestamp;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SceneQueryStaticTimestamp, PxScene, PxU32 > SceneQueryStaticTimestamp;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_BounceThresholdVelocity, PxScene, const PxReal, PxReal > BounceThresholdVelocity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_TaskManager, PxScene, physx::pxtask::TaskManager * > TaskManager;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SolverBatchSize, PxScene, PxU32, PxU32 > SolverBatchSize;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_NbContactDataBlocks, PxScene, PxU32 > NbContactDataBlocks;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_MaxNbContactDataBlocksUsed, PxScene, PxU32 > MaxNbContactDataBlocksUsed;
		PxCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Aggregates, PxScene, PxAggregate * > Aggregates;
		PxFilteredCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Actors, PxScene, PxActor *, PxActorTypeSelectionFlags > Actors;
		PxCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Articulations, PxScene, PxArticulation * > Articulations;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Constraints, PxScene, PxConstraint * > Constraints;
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ClientBehaviorBits, PxScene, PxClientID, PxU32 > ClientBehaviorBits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ContactModifyCallback, PxScene, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShaderData, PxScene, const void * > FilterShaderData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShaderDataSize, PxScene, PxU32 > FilterShaderDataSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShader, PxScene, PxSimulationFilterShader > FilterShader;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterCallback, PxScene, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_DynamicTreeRebuildRateHint, PxScene, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_VisualizationCullingBox, PxScene, const PxBounds3 &, const PxBounds3 & > VisualizationCullingBox;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_UserData, PxScene, void *, void * > UserData;
		SimulationStatisticsProperty SimulationStatistics;

		PX_PHYSX_CORE_API PxSceneGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxScene*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 23; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Flags, inStartIndex + 0 );; 
			inOperator( Gravity, inStartIndex + 1 );; 
			inOperator( Timestamp, inStartIndex + 2 );; 
			inOperator( SceneQueryStaticTimestamp, inStartIndex + 3 );; 
			inOperator( BounceThresholdVelocity, inStartIndex + 4 );; 
			inOperator( TaskManager, inStartIndex + 5 );; 
			inOperator( SolverBatchSize, inStartIndex + 6 );; 
			inOperator( NbContactDataBlocks, inStartIndex + 7 );; 
			inOperator( MaxNbContactDataBlocksUsed, inStartIndex + 8 );; 
			inOperator( Aggregates, inStartIndex + 9 );; 
			inOperator( Actors, inStartIndex + 10 );; 
			inOperator( Articulations, inStartIndex + 11 );; 
			inOperator( Constraints, inStartIndex + 12 );; 
			inOperator( ClientBehaviorBits, inStartIndex + 13 );; 
			inOperator( ContactModifyCallback, inStartIndex + 14 );; 
			inOperator( FilterShaderData, inStartIndex + 15 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 16 );; 
			inOperator( FilterShader, inStartIndex + 17 );; 
			inOperator( FilterCallback, inStartIndex + 18 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 19 );; 
			inOperator( VisualizationCullingBox, inStartIndex + 20 );; 
			inOperator( UserData, inStartIndex + 21 );; 
			inOperator( SimulationStatistics, inStartIndex + 22 );; 
			return 23 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxScene> { PxSceneGeneratedInfo Info; };

	class PxGeometry;
	struct PxGeometryGeneratedValues
	{
		 PX_PHYSX_CORE_API PxGeometryGeneratedValues( const PxGeometry* inSource );
	};
	struct PxGeometryGeneratedInfo

	{
		static const char* getClassName() { return "PxGeometry"; }

		PX_PHYSX_CORE_API PxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxGeometry> { PxGeometryGeneratedInfo Info; };

	class PxBoxGeometry;
	struct PxBoxGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxVec3 HalfExtents;
		 PX_PHYSX_CORE_API PxBoxGeometryGeneratedValues( const PxBoxGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxBoxGeometry, HalfExtents, PxBoxGeometryGeneratedValues)
	struct PxBoxGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxBoxGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxBoxGeometry_HalfExtents, PxBoxGeometry, PxVec3, PxVec3 > HalfExtents;

		PX_PHYSX_CORE_API PxBoxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxBoxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( HalfExtents, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxBoxGeometry> { PxBoxGeometryGeneratedInfo Info; };

	class PxCapsuleGeometry;
	struct PxCapsuleGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxReal Radius;
		PxReal HalfHeight;
		 PX_PHYSX_CORE_API PxCapsuleGeometryGeneratedValues( const PxCapsuleGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, Radius, PxCapsuleGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, HalfHeight, PxCapsuleGeometryGeneratedValues)
	struct PxCapsuleGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxCapsuleGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_Radius, PxCapsuleGeometry, PxReal, PxReal > Radius;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_HalfHeight, PxCapsuleGeometry, PxReal, PxReal > HalfHeight;

		PX_PHYSX_CORE_API PxCapsuleGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxCapsuleGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Radius, inStartIndex + 0 );; 
			inOperator( HalfHeight, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCapsuleGeometry> { PxCapsuleGeometryGeneratedInfo Info; };

	class PxMeshScale;
	struct PxMeshScaleGeneratedValues
	{
		PxVec3 Scale;
		PxQuat Rotation;
		 PX_PHYSX_CORE_API PxMeshScaleGeneratedValues( const PxMeshScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Scale, PxMeshScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Rotation, PxMeshScaleGeneratedValues)
	struct PxMeshScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxMeshScale"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Scale, PxMeshScale, PxVec3, PxVec3 > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Rotation, PxMeshScale, PxQuat, PxQuat > Rotation;

		PX_PHYSX_CORE_API PxMeshScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxMeshScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( Rotation, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMeshScale> { PxMeshScaleGeneratedInfo Info; };

	class PxConvexMeshGeometry;
	struct PxConvexMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxMeshScale Scale;
		PxConvexMesh * ConvexMesh;
		 PX_PHYSX_CORE_API PxConvexMeshGeometryGeneratedValues( const PxConvexMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, Scale, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, ConvexMesh, PxConvexMeshGeometryGeneratedValues)
	struct PxConvexMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxConvexMeshGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_Scale, PxConvexMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_ConvexMesh, PxConvexMeshGeometry, PxConvexMesh *, PxConvexMesh * > ConvexMesh;

		PX_PHYSX_CORE_API PxConvexMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxConvexMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( ConvexMesh, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConvexMeshGeometry> { PxConvexMeshGeometryGeneratedInfo Info; };

	class PxSphereGeometry;
	struct PxSphereGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxReal Radius;
		 PX_PHYSX_CORE_API PxSphereGeometryGeneratedValues( const PxSphereGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphereGeometry, IsValid, PxSphereGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphereGeometry, Radius, PxSphereGeometryGeneratedValues)
	struct PxSphereGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxSphereGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphereGeometry_IsValid, PxSphereGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphereGeometry_Radius, PxSphereGeometry, PxReal, PxReal > Radius;

		PX_PHYSX_CORE_API PxSphereGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSphereGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Radius, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphereGeometry> { PxSphereGeometryGeneratedInfo Info; };

	class PxPlaneGeometry;
	struct PxPlaneGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		 PX_PHYSX_CORE_API PxPlaneGeometryGeneratedValues( const PxPlaneGeometry* inSource );
	};
	struct PxPlaneGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxPlaneGeometry"; }

		PX_PHYSX_CORE_API PxPlaneGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxPlaneGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPlaneGeometry> { PxPlaneGeometryGeneratedInfo Info; };

	static PxU32ToName g_physx__PxMeshGeometryFlag__EnumConversion[] = {
		{ "eDOUBLE_SIDED", static_cast<PxU32>( physx::PxMeshGeometryFlag::eDOUBLE_SIDED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxMeshGeometryFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxMeshGeometryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxTriangleMeshGeometry;
	struct PxTriangleMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxMeshScale Scale;
		PxMeshGeometryFlags MeshFlags;
		PxTriangleMesh * TriangleMesh;
		 PX_PHYSX_CORE_API PxTriangleMeshGeometryGeneratedValues( const PxTriangleMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, Scale, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, MeshFlags, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, TriangleMesh, PxTriangleMeshGeometryGeneratedValues)
	struct PxTriangleMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxTriangleMeshGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_Scale, PxTriangleMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_MeshFlags, PxTriangleMeshGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > MeshFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_TriangleMesh, PxTriangleMeshGeometry, PxTriangleMesh *, PxTriangleMesh * > TriangleMesh;

		PX_PHYSX_CORE_API PxTriangleMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxTriangleMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scale, inStartIndex + 0 );; 
			inOperator( MeshFlags, inStartIndex + 1 );; 
			inOperator( TriangleMesh, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTriangleMeshGeometry> { PxTriangleMeshGeometryGeneratedInfo Info; };

	class PxHeightFieldGeometry;
	struct PxHeightFieldGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		PxHeightField * HeightField;
		PxReal HeightScale;
		PxReal RowScale;
		PxReal ColumnScale;
		PxMeshGeometryFlags HeightFieldFlags;
		 PX_PHYSX_CORE_API PxHeightFieldGeometryGeneratedValues( const PxHeightFieldGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightField, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, RowScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, ColumnScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightFieldFlags, PxHeightFieldGeometryGeneratedValues)
	struct PxHeightFieldGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxHeightFieldGeometry"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightField, PxHeightFieldGeometry, PxHeightField *, PxHeightField * > HeightField;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightScale, PxHeightFieldGeometry, PxReal, PxReal > HeightScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_RowScale, PxHeightFieldGeometry, PxReal, PxReal > RowScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_ColumnScale, PxHeightFieldGeometry, PxReal, PxReal > ColumnScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightFieldFlags, PxHeightFieldGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > HeightFieldFlags;

		PX_PHYSX_CORE_API PxHeightFieldGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxHeightFieldGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( HeightField, inStartIndex + 0 );; 
			inOperator( HeightScale, inStartIndex + 1 );; 
			inOperator( RowScale, inStartIndex + 2 );; 
			inOperator( ColumnScale, inStartIndex + 3 );; 
			inOperator( HeightFieldFlags, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldGeometry> { PxHeightFieldGeometryGeneratedInfo Info; };

	static PxU32ToName g_physx__PxHeightFieldFormat__EnumConversion[] = {
		{ "eS16_TM", static_cast<PxU32>( physx::PxHeightFieldFormat::eS16_TM ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxHeightFieldFormat::Enum > { PxEnumTraits() : NameConversion( g_physx__PxHeightFieldFormat__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxHeightFieldFlag__EnumConversion[] = {
		{ "eNO_BOUNDARY_EDGES", static_cast<PxU32>( physx::PxHeightFieldFlag::eNO_BOUNDARY_EDGES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxHeightFieldFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxHeightFieldFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxHeightFieldDesc;
	struct PxHeightFieldDescGeneratedValues
	{
		_Bool IsValid;
		PxU32 NbRows;
		PxU32 NbColumns;
		PxHeightFieldFormat::Enum Format;
		PxStridedData Samples;
		PxReal Thickness;
		PxReal ConvexEdgeThreshold;
		PxHeightFieldFlags Flags;
		 PX_PHYSX_CORE_API PxHeightFieldDescGeneratedValues( const PxHeightFieldDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, IsValid, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbRows, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbColumns, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Format, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Samples, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Thickness, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, ConvexEdgeThreshold, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Flags, PxHeightFieldDescGeneratedValues)
	struct PxHeightFieldDescGeneratedInfo

	{
		static const char* getClassName() { return "PxHeightFieldDesc"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_IsValid, PxHeightFieldDesc, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbRows, PxHeightFieldDesc, PxU32, PxU32 > NbRows;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbColumns, PxHeightFieldDesc, PxU32, PxU32 > NbColumns;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Format, PxHeightFieldDesc, PxHeightFieldFormat::Enum, PxHeightFieldFormat::Enum > Format;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Samples, PxHeightFieldDesc, PxStridedData, PxStridedData > Samples;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Thickness, PxHeightFieldDesc, PxReal, PxReal > Thickness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_ConvexEdgeThreshold, PxHeightFieldDesc, PxReal, PxReal > ConvexEdgeThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Flags, PxHeightFieldDesc, PxHeightFieldFlags, PxHeightFieldFlags > Flags;

		PX_PHYSX_CORE_API PxHeightFieldDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxHeightFieldDesc*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( NbRows, inStartIndex + 1 );; 
			inOperator( NbColumns, inStartIndex + 2 );; 
			inOperator( Format, inStartIndex + 3 );; 
			inOperator( Samples, inStartIndex + 4 );; 
			inOperator( Thickness, inStartIndex + 5 );; 
			inOperator( ConvexEdgeThreshold, inStartIndex + 6 );; 
			inOperator( Flags, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldDesc> { PxHeightFieldDescGeneratedInfo Info; };

	struct PxClothParticle;
	struct PxClothParticleGeneratedValues
	{
		PxVec3 Pos;
		PxReal InvWeight;
		 PX_PHYSX_CORE_API PxClothParticleGeneratedValues( const PxClothParticle* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticle, Pos, PxClothParticleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothParticle, InvWeight, PxClothParticleGeneratedValues)
	struct PxClothParticleGeneratedInfo

	{
		static const char* getClassName() { return "PxClothParticle"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticle_Pos, PxClothParticle, PxVec3, PxVec3 > Pos;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothParticle_InvWeight, PxClothParticle, PxReal, PxReal > InvWeight;

		PX_PHYSX_CORE_API PxClothParticleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxClothParticle*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Pos, inStartIndex + 0 );; 
			inOperator( InvWeight, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothParticle> { PxClothParticleGeneratedInfo Info; };

	class PxSceneLimits;
	struct PxSceneLimitsGeneratedValues
	{
		PxU32 MaxNbActors;
		PxU32 MaxNbBodies;
		PxU32 MaxNbStaticShapes;
		PxU32 MaxNbDynamicShapes;
		PxU32 MaxNbConstraints;
		 PX_PHYSX_CORE_API PxSceneLimitsGeneratedValues( const PxSceneLimits* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbActors, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbBodies, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbStaticShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbDynamicShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbConstraints, PxSceneLimitsGeneratedValues)
	struct PxSceneLimitsGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneLimits"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbActors, PxSceneLimits, PxU32, PxU32 > MaxNbActors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbBodies, PxSceneLimits, PxU32, PxU32 > MaxNbBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbStaticShapes, PxSceneLimits, PxU32, PxU32 > MaxNbStaticShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbDynamicShapes, PxSceneLimits, PxU32, PxU32 > MaxNbDynamicShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbConstraints, PxSceneLimits, PxU32, PxU32 > MaxNbConstraints;

		PX_PHYSX_CORE_API PxSceneLimitsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSceneLimits*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( MaxNbActors, inStartIndex + 0 );; 
			inOperator( MaxNbBodies, inStartIndex + 1 );; 
			inOperator( MaxNbStaticShapes, inStartIndex + 2 );; 
			inOperator( MaxNbDynamicShapes, inStartIndex + 3 );; 
			inOperator( MaxNbConstraints, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneLimits> { PxSceneLimitsGeneratedInfo Info; };

	static PxU32ToName g_physx__PxPruningStructure__EnumConversion[] = {
		{ "eNONE", static_cast<PxU32>( physx::PxPruningStructure::eNONE ) },
		{ "eDYNAMIC_AABB_TREE", static_cast<PxU32>( physx::PxPruningStructure::eDYNAMIC_AABB_TREE ) },
		{ "eSTATIC_AABB_TREE", static_cast<PxU32>( physx::PxPruningStructure::eSTATIC_AABB_TREE ) },
		{ "eLAST", static_cast<PxU32>( physx::PxPruningStructure::eLAST ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxPruningStructure::Enum > { PxEnumTraits() : NameConversion( g_physx__PxPruningStructure__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSceneDesc;
	struct PxSceneDescGeneratedValues
	{
		_Bool IsValid;
		PxVec3 Gravity;
		PxSimulationEventCallback * SimulationEventCallback;
		PxContactModifyCallback * ContactModifyCallback;
		const void * FilterShaderData;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxSceneLimits Limits;
		PxReal SweepEpsilonDistance;
		PxReal ContactCorrelationDistance;
		PxReal BounceThresholdVelocity;
		PxSceneFlags Flags;
		pxtask::CpuDispatcher * CpuDispatcher;
		pxtask::GpuDispatcher * GpuDispatcher;
		pxtask::SpuDispatcher * SpuDispatcher;
		PxPruningStructure::Enum StaticStructure;
		PxPruningStructure::Enum DynamicStructure;
		PxU32 DynamicTreeRebuildRateHint;
		void * UserData;
		PxU32 SolverBatchSize;
		PxReal SweptIntegrationLinearSpeedFactor;
		PxReal SweptIntegrationAngularSpeedFactor;
		PxU32 NbContactDataBlocks;
		PxU32 MaxNbContactDataBlocks;
		PxU32 ContactReportStreamBufferSize;
		 PX_PHYSX_CORE_API PxSceneDescGeneratedValues( const PxSceneDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, IsValid, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Gravity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SimulationEventCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactModifyCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderDataSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShader, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Limits, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweepEpsilonDistance, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactCorrelationDistance, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, BounceThresholdVelocity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Flags, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, StaticStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicTreeRebuildRateHint, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, UserData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SolverBatchSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweptIntegrationLinearSpeedFactor, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweptIntegrationAngularSpeedFactor, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, NbContactDataBlocks, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, MaxNbContactDataBlocks, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactReportStreamBufferSize, PxSceneDescGeneratedValues)
	struct PxSceneDescGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneDesc"; }
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ToDefault, PxSceneDesc, const PxTolerancesScale & > ToDefault;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_IsValid, PxSceneDesc, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Gravity, PxSceneDesc, PxVec3, PxVec3 > Gravity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SimulationEventCallback, PxSceneDesc, PxSimulationEventCallback *, PxSimulationEventCallback * > SimulationEventCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactModifyCallback, PxSceneDesc, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderData, PxSceneDesc, const void *, const void * > FilterShaderData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderDataSize, PxSceneDesc, PxU32, PxU32 > FilterShaderDataSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShader, PxSceneDesc, PxSimulationFilterShader, PxSimulationFilterShader > FilterShader;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterCallback, PxSceneDesc, PxSimulationFilterCallback *, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Limits, PxSceneDesc, PxSceneLimits, PxSceneLimits > Limits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweepEpsilonDistance, PxSceneDesc, PxReal, PxReal > SweepEpsilonDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactCorrelationDistance, PxSceneDesc, PxReal, PxReal > ContactCorrelationDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_BounceThresholdVelocity, PxSceneDesc, PxReal, PxReal > BounceThresholdVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Flags, PxSceneDesc, PxSceneFlags, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CpuDispatcher, PxSceneDesc, pxtask::CpuDispatcher *, pxtask::CpuDispatcher * > CpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuDispatcher, PxSceneDesc, pxtask::GpuDispatcher *, pxtask::GpuDispatcher * > GpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SpuDispatcher, PxSceneDesc, pxtask::SpuDispatcher *, pxtask::SpuDispatcher * > SpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_StaticStructure, PxSceneDesc, PxPruningStructure::Enum, PxPruningStructure::Enum > StaticStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicStructure, PxSceneDesc, PxPruningStructure::Enum, PxPruningStructure::Enum > DynamicStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicTreeRebuildRateHint, PxSceneDesc, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_UserData, PxSceneDesc, void *, void * > UserData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SolverBatchSize, PxSceneDesc, PxU32, PxU32 > SolverBatchSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweptIntegrationLinearSpeedFactor, PxSceneDesc, PxReal, PxReal > SweptIntegrationLinearSpeedFactor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweptIntegrationAngularSpeedFactor, PxSceneDesc, PxReal, PxReal > SweptIntegrationAngularSpeedFactor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_NbContactDataBlocks, PxSceneDesc, PxU32, PxU32 > NbContactDataBlocks;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_MaxNbContactDataBlocks, PxSceneDesc, PxU32, PxU32 > MaxNbContactDataBlocks;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactReportStreamBufferSize, PxSceneDesc, PxU32, PxU32 > ContactReportStreamBufferSize;

		PX_PHYSX_CORE_API PxSceneDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSceneDesc*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 27; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ToDefault, inStartIndex + 0 );; 
			inOperator( IsValid, inStartIndex + 1 );; 
			inOperator( Gravity, inStartIndex + 2 );; 
			inOperator( SimulationEventCallback, inStartIndex + 3 );; 
			inOperator( ContactModifyCallback, inStartIndex + 4 );; 
			inOperator( FilterShaderData, inStartIndex + 5 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 6 );; 
			inOperator( FilterShader, inStartIndex + 7 );; 
			inOperator( FilterCallback, inStartIndex + 8 );; 
			inOperator( Limits, inStartIndex + 9 );; 
			inOperator( SweepEpsilonDistance, inStartIndex + 10 );; 
			inOperator( ContactCorrelationDistance, inStartIndex + 11 );; 
			inOperator( BounceThresholdVelocity, inStartIndex + 12 );; 
			inOperator( Flags, inStartIndex + 13 );; 
			inOperator( CpuDispatcher, inStartIndex + 14 );; 
			inOperator( GpuDispatcher, inStartIndex + 15 );; 
			inOperator( SpuDispatcher, inStartIndex + 16 );; 
			inOperator( StaticStructure, inStartIndex + 17 );; 
			inOperator( DynamicStructure, inStartIndex + 18 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 19 );; 
			inOperator( UserData, inStartIndex + 20 );; 
			inOperator( SolverBatchSize, inStartIndex + 21 );; 
			inOperator( SweptIntegrationLinearSpeedFactor, inStartIndex + 22 );; 
			inOperator( SweptIntegrationAngularSpeedFactor, inStartIndex + 23 );; 
			inOperator( NbContactDataBlocks, inStartIndex + 24 );; 
			inOperator( MaxNbContactDataBlocks, inStartIndex + 25 );; 
			inOperator( ContactReportStreamBufferSize, inStartIndex + 26 );; 
			return 27 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneDesc> { PxSceneDescGeneratedInfo Info; };

	static PxU32ToName g_physx__PxSimulationStatistics__VolumeTypeConversion[] = {
		{ "eRIGID_BODY", static_cast<PxU32>( physx::PxSimulationStatistics::eRIGID_BODY ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( physx::PxSimulationStatistics::ePARTICLE_SYSTEM ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSimulationStatistics::VolumeType > { PxEnumTraits() : NameConversion( g_physx__PxSimulationStatistics__VolumeTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxSimulationStatistics__RbPairStatsTypeConversion[] = {
		{ "eDISCRETE_CONTACT_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eDISCRETE_CONTACT_PAIRS ) },
		{ "eSWEPT_INTEGRATION_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eSWEPT_INTEGRATION_PAIRS ) },
		{ "eMODIFIED_CONTACT_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eMODIFIED_CONTACT_PAIRS ) },
		{ "eTRIGGER_PAIRS", static_cast<PxU32>( physx::PxSimulationStatistics::eTRIGGER_PAIRS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSimulationStatistics::RbPairStatsType > { PxEnumTraits() : NameConversion( g_physx__PxSimulationStatistics__RbPairStatsTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSimulationStatistics;
	struct PxSimulationStatisticsGeneratedValues
	{
		PxU32 NumActiveConstraints;
		PxU32 NumActiveDynamicBodies;
		PxU32 NumActiveKinematicBodies;
		PxU32 NumStaticBodies;
		PxU32 NumDynamicBodies;
		PxU32 NumAxisSolverConstraints;
		PxU32 NumDiscreteContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumModifiedContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumSweptIntegrationPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumTriggerPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumBroadPhaseAdds[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NumBroadPhaseRemoves[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NumShapes[PxGeometryType::eGEOMETRY_COUNT];
		 PX_PHYSX_CORE_API PxSimulationStatisticsGeneratedValues( const PxSimulationStatistics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveKinematicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumStaticBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumAxisSolverConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumDiscreteContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumModifiedContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumSweptIntegrationPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumTriggerPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumBroadPhaseAdds, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumBroadPhaseRemoves, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumShapes, PxSimulationStatisticsGeneratedValues)
	struct PxSimulationStatisticsGeneratedInfo

	{
		static const char* getClassName() { return "PxSimulationStatistics"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveConstraints, PxSimulationStatistics, PxU32, PxU32 > NumActiveConstraints;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NumActiveDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveKinematicBodies, PxSimulationStatistics, PxU32, PxU32 > NumActiveKinematicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumStaticBodies, PxSimulationStatistics, PxU32, PxU32 > NumStaticBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NumDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumAxisSolverConstraints, PxSimulationStatistics, PxU32, PxU32 > NumAxisSolverConstraints;
		NumDiscreteContactPairsProperty NumDiscreteContactPairs;
		NumModifiedContactPairsProperty NumModifiedContactPairs;
		NumSweptIntegrationPairsProperty NumSweptIntegrationPairs;
		NumTriggerPairsProperty NumTriggerPairs;
		NumBroadPhaseAddsProperty NumBroadPhaseAdds;
		NumBroadPhaseRemovesProperty NumBroadPhaseRemoves;
		NumShapesProperty NumShapes;

		PX_PHYSX_CORE_API PxSimulationStatisticsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSimulationStatistics*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 13; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NumActiveConstraints, inStartIndex + 0 );; 
			inOperator( NumActiveDynamicBodies, inStartIndex + 1 );; 
			inOperator( NumActiveKinematicBodies, inStartIndex + 2 );; 
			inOperator( NumStaticBodies, inStartIndex + 3 );; 
			inOperator( NumDynamicBodies, inStartIndex + 4 );; 
			inOperator( NumAxisSolverConstraints, inStartIndex + 5 );; 
			inOperator( NumDiscreteContactPairs, inStartIndex + 6 );; 
			inOperator( NumModifiedContactPairs, inStartIndex + 7 );; 
			inOperator( NumSweptIntegrationPairs, inStartIndex + 8 );; 
			inOperator( NumTriggerPairs, inStartIndex + 9 );; 
			inOperator( NumBroadPhaseAdds, inStartIndex + 10 );; 
			inOperator( NumBroadPhaseRemoves, inStartIndex + 11 );; 
			inOperator( NumShapes, inStartIndex + 12 );; 
			return 13 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSimulationStatistics> { PxSimulationStatisticsGeneratedInfo Info; };

	static PxU32ToName g_physx__PxDataAccessFlag__EnumConversion[] = {
		{ "eREADABLE", static_cast<PxU32>( physx::PxDataAccessFlag::eREADABLE ) },
		{ "eWRITABLE", static_cast<PxU32>( physx::PxDataAccessFlag::eWRITABLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxDataAccessFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxDataAccessFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxLockedData;
	struct PxLockedDataGeneratedValues
	{
		 PX_PHYSX_CORE_API PxLockedDataGeneratedValues( const PxLockedData* inSource );
	};
	struct PxLockedDataGeneratedInfo

	{
		static const char* getClassName() { return "PxLockedData"; }

		PX_PHYSX_CORE_API PxLockedDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxLockedData*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxLockedData> { PxLockedDataGeneratedInfo Info; };

	class PxParticleReadData;
	struct PxParticleReadDataGeneratedValues
		: PxLockedDataGeneratedValues	{
		PxU32 NumValidParticles;
		PxU32 ValidParticleRange;
		const PxU32 * ValidParticleBitmap;
		PxStrideIterator<const PxVec3> PositionBuffer;
		PxStrideIterator<const PxVec3> VelocityBuffer;
		PxStrideIterator<const PxF32> RestOffsetBuffer;
		PxStrideIterator<const PxParticleFlags> FlagsBuffer;
		PxStrideIterator<const PxVec3> CollisionNormalBuffer;
		 PX_PHYSX_CORE_API PxParticleReadDataGeneratedValues( const PxParticleReadData* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, NumValidParticles, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleRange, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleBitmap, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, PositionBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, VelocityBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, RestOffsetBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, FlagsBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, CollisionNormalBuffer, PxParticleReadDataGeneratedValues)
	struct PxParticleReadDataGeneratedInfo
		: PxLockedDataGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleReadData"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_NumValidParticles, PxParticleReadData, PxU32, PxU32 > NumValidParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleRange, PxParticleReadData, PxU32, PxU32 > ValidParticleRange;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleBitmap, PxParticleReadData, const PxU32 *, const PxU32 * > ValidParticleBitmap;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_PositionBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > PositionBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_VelocityBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > VelocityBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_RestOffsetBuffer, PxParticleReadData, PxStrideIterator<const PxF32>, PxStrideIterator<const PxF32> > RestOffsetBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_FlagsBuffer, PxParticleReadData, PxStrideIterator<const PxParticleFlags>, PxStrideIterator<const PxParticleFlags> > FlagsBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_CollisionNormalBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > CollisionNormalBuffer;

		PX_PHYSX_CORE_API PxParticleReadDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleReadData*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxLockedDataGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxLockedDataGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxLockedDataGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxLockedDataGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NumValidParticles, inStartIndex + 0 );; 
			inOperator( ValidParticleRange, inStartIndex + 1 );; 
			inOperator( ValidParticleBitmap, inStartIndex + 2 );; 
			inOperator( PositionBuffer, inStartIndex + 3 );; 
			inOperator( VelocityBuffer, inStartIndex + 4 );; 
			inOperator( RestOffsetBuffer, inStartIndex + 5 );; 
			inOperator( FlagsBuffer, inStartIndex + 6 );; 
			inOperator( CollisionNormalBuffer, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleReadData> { PxParticleReadDataGeneratedInfo Info; };

	class PxClothReadData;
	struct PxClothReadDataGeneratedValues
		: PxLockedDataGeneratedValues	{
		const PxClothParticle * Particles;
		const PxClothParticle * PreviousParticles;
		 PX_PHYSX_CORE_API PxClothReadDataGeneratedValues( const PxClothReadData* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothReadData, Particles, PxClothReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxClothReadData, PreviousParticles, PxClothReadDataGeneratedValues)
	struct PxClothReadDataGeneratedInfo
		: PxLockedDataGeneratedInfo
	{
		static const char* getClassName() { return "PxClothReadData"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothReadData_Particles, PxClothReadData, const PxClothParticle *, const PxClothParticle * > Particles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxClothReadData_PreviousParticles, PxClothReadData, const PxClothParticle *, const PxClothParticle * > PreviousParticles;

		PX_PHYSX_CORE_API PxClothReadDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxClothReadData*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxLockedDataGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxLockedDataGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxLockedDataGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxLockedDataGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Particles, inStartIndex + 0 );; 
			inOperator( PreviousParticles, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxClothReadData> { PxClothReadDataGeneratedInfo Info; };



#undef THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON
#undef PX_PROPERTY_INFO_NAME
